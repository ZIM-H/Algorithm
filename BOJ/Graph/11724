import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


public class Main {
    public static int n,m;
    public static int[] root; // 루트 노드 배열
    public static int findroot(int x){
        if(x == root[x]) return x;
        return root[x] = findroot(root[x]);
    }

    public static void connect(int x, int y){
        x = findroot(root[x]);
        y = findroot(root[y]);
        if(x < y) root[y] = x;
        else root[x] = y;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        root = new int[n+1];
        int[][] node = new int[m+1][2]; // 노드 입력받는 배열
        int cnt = 0; // 연결 요소 개수

        // 노드 입력 받기
        for(int i=1; i<=m; i++){
            st = new StringTokenizer(br.readLine());
            node[i][0] = Integer.parseInt(st.nextToken());
            node[i][1] = Integer.parseInt(st.nextToken());
        }
        // 루트 자기자신으로 초기화
        for(int i=1; i<=n; i++){
            root[i] =i;
        }

        // 배열 각부분 1번째 요소 기준 정렬 (오름차순)
        Arrays.sort(node, Comparator.comparingInt(o -> o[1]));

        // 노드 연결
        for(int i=1; i<=m; i++){
            if(findroot(node[i][0]) != findroot(node[i][1])){
                connect(node[i][0], node[i][1]);
            }
        }

        // root 로 연결 요소 개수 확인
        boolean[] check = new boolean[n+1];
        for (int i=1; i<=n; i++){
            if(!check[root[i]]){
                check[root[i]] = true;
                cnt++;
            }
        }
        System.out.println(cnt);

    }
}
